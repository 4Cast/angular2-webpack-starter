//////////////////////////////////////////////////////////////////////////// SCPY Validators//////////////////////////////////////////////////////////////////////////var validationErrors = [];var thisErrorNumber = null;var thisErrorMessage = '';model.supplierPayment.events.validate = function(event) {    this.validationErrors = JSON.stringify(validationErrors);}model.supplierPayment.paymentDetails.events.validate = function(event) {    debugger;    thisErrorNumber = 110;    thisErrorMessage = "Payment details cannot be blank."    removeError(thisErrorNumber);    if (this.paymentDetails == '' || this.paymentDetails == ' ') {        pushError(thisErrorNumber, thisErrorMessage)    }}model.supplierPayment.supplierReference.events.validate = function(event) {    thisErrorNumber = 120;    thisErrorMessage = "Supplier reference cannot be blank.";    removeError(thisErrorNumber);    if (this.supplierReference == '') {        pushError(thisErrorNumber, thisErrorMessage)    }}////// toDateClaimed validation////model.supplierPayment.toDateClaimed_int.events.validate = function(event) {	thisErrorNumber = 130;    thisErrorMessage = "Claimed to date cannot be less than the previously claimed to date amount.";    removeError(thisErrorNumber);    if  (this.toDateClaimed_int < this.prevToDateClaimed_int) {        pushError(thisErrorNumber, thisErrorMessage)    }}////// toDateApproved validation////model.supplierPayment.toDateApproved_int.events.validate = function(event) {	thisErrorNumber = 140;    thisErrorMessage = "Approved to date cannot be less than the previously approved to date amount.";    removeError(thisErrorNumber);    if  (this.toDateApproved_int < this.prevToDateApproved_int) {        pushError(thisErrorNumber, thisErrorMessage)    }}////// thisRetentionTaken validation////model.supplierPayment.thisRetentionTaken_int.events.validate = function(event) {	thisErrorNumber = 150;    thisErrorMessage = "Retention taken cannot exceed the approved amount.";    removeError(thisErrorNumber);    if  (this.thisRetentionTaken_int > this.thisApprovedAmount_int) {        pushError(thisErrorNumber, thisErrorMessage)    }}////// thisRetentionReleased validation////model.supplierPayment.thisRetentionReleased_int.events.validate = function(event) {		thisErrorNumber = 160;	thisErrorMessage = "Retention released cannot exceed the total retention balance.";    removeError(thisErrorNumber);    if  (this.thisRetentionReleased_int > (this.thisRetentionTaken_int + this.prevRetentionBalance_int)) {        pushError(thisErrorNumber, thisErrorMessage)    }}function pushError(thisErrorNumber, thisErrorMessage) {    var newError = {        "errorNumber": thisErrorNumber,        "errorMessage": thisErrorMessage    };    validationErrors.push(newError);}function removeError(errorNumber) {    for (var i = 0; i < validationErrors.length; i++) {        if (validationErrors[i].errorNumber === errorNumber) {            validationErrors.splice(i, 1);            i--;        }    };}