model.supplierPayment = new DataClass("supplierPayments", "public");model.supplierPayment.id = new Attribute("storage", "uuid", "key", {    autogenerate: true});model.supplierPayment.paymentDate = new Attribute("storage", "date");model.supplierPayment.paymentDetails = new Attribute("storage", "string");model.supplierPayment.paymentNumber = new Attribute("storage", "long64");model.supplierPayment.supplierReference = new Attribute("storage", "string");model.supplierPayment.accountingPeriod = new Attribute("relatedEntity", "period", 'period');model.supplierPayment.isApproved = new Attribute("storage", "bool");model.supplierPayment.isExported = new Attribute("storage", "bool");model.supplierPayment.isFinalPayment = new Attribute("storage", "bool");model.supplierPayment.thisClaimedAmount_int = new Attribute("storage", 'long64');model.supplierPayment.thisApprovedAmount_int = new Attribute("storage", 'long64');model.supplierPayment.thisApprovedAmountTax_int = new Attribute("storage", 'long64');model.supplierPayment.prevRetentionBalance_int = new Attribute('storage', 'long64');model.supplierPayment.thisRetentionTaken_int = new Attribute("storage", 'long64');model.supplierPayment.thisRetentionReleased_int = new Attribute("storage", 'long64');model.supplierPayment.thisPaidNet_int = new Attribute("storage", "long64");model.supplierPayment.prevToDateClaimed_int = new Attribute("storage", 'long64');model.supplierPayment.prevToDateApproved_int = new Attribute("storage", 'long64');model.supplierPayment.toDateClaimed_int = new Attribute("storage", 'long64');model.supplierPayment.toDateApproved_int = new Attribute("storage", 'long64');model.supplierPayment.thisClaimedAmount = new Attribute("calculated", 'number');model.supplierPayment.thisApprovedAmount = new Attribute("calculated", 'number');model.supplierPayment.thisApprovedAmountTax = new Attribute("calculated", 'number');model.supplierPayment.thisRetentionTaken = new Attribute("calculated", 'number');model.supplierPayment.thisRetentionReleased = new Attribute("calculated", 'number');model.supplierPayment.thisPaidNet = new Attribute("calculated", "number");model.supplierPayment.prevToDateClaimed_int = new Attribute("storage", 'long64');model.supplierPayment.prevToDateClaimed = new Attribute("calculated", 'number');model.supplierPayment.prevToDateApproved = new Attribute("calculated", 'number');model.supplierPayment.prevRetentionBalance = new Attribute('calculated', 'number');model.supplierPayment.toDateClaimed = new Attribute("calculated", 'number');model.supplierPayment.toDateApproved = new Attribute("calculated", 'number');model.supplierPayment.approvalStatus = new Attribute("storage", "string");model.supplierPayment.exportStatus = new Attribute("storage", "string");model.supplierPayment.isNewPayment = new Attribute("storage", "bool");model.supplierPayment.isInitialised = new Attribute("storage", 'bool');model.supplierPayment.isBeingImported = new Attribute("storage", 'bool');model.supplierPayment.validationErrors = new Attribute("storage", "string");// we want to be able to do serverRefresh on client without causing validation errors// to stop the refresh. This is because we want to handle validation errors individually for each// attribute (when it is changed on the client) // When we load the entity on the client we set dontStopOnErrors = true// Before we save the entity we must set dontStopOnErrors = falsemodel.supplierPayment.dontStopOnErrors = new Attribute("storage", "bool");model.supplierPayment.paymentSubcontract = new Attribute("relatedEntity", "subcontract", "subcontract");model.supplierPayment.paymentCostCode = new Attribute("relatedEntity", "costCode", "paymentSubcontract.subcontractCostCode");//////////////////////////////////////////////////////////////////////////// Getters//////////////////////////////////////////////////////////////////////////model.supplierPayment.thisClaimedAmount.onGet = function() {    return this.thisClaimedAmount_int / multiplier};model.supplierPayment.thisApprovedAmount.onGet = function() {    return this.thisApprovedAmount_int / multiplier};model.supplierPayment.thisApprovedAmountTax.onGet = function() {    return this.thisApprovedAmountTax_int / multiplier};model.supplierPayment.thisRetentionTaken.onGet = function() {    return this.thisRetentionTaken_int / multiplier};model.supplierPayment.thisRetentionReleased.onGet = function() {    return this.thisRetentionReleased_int / multiplier};model.supplierPayment.prevToDateClaimed.onGet = function() {    return this.prevToDateClaimed_int / multiplier};model.supplierPayment.prevToDateApproved.onGet = function() {    return this.prevToDateApproved_int / multiplier};model.supplierPayment.prevRetentionBalance.onGet = function() {    return this.prevRetentionBalance_int / multiplier};model.supplierPayment.toDateClaimed.onGet = function() {    return this.toDateClaimed_int / multiplier};model.supplierPayment.toDateApproved.onGet = function() {    return this.toDateApproved_int / multiplier};model.supplierPayment.thisPaidNet.onGet = function() {    return this.thisPaidNet_int / multiplier};//////////////////////////////////////////////////////////////////////////// Setters//////////////////////////////////////////////////////////////////////////model.supplierPayment.thisRetentionReleased.onSet = function(value) {    this.thisRetentionReleased_int = value * multiplier;    calculateNet(this)};model.supplierPayment.thisRetentionTaken.onSet = function(value) {    this.thisRetentionTaken_int = value * multiplier;    calculateNet(this);};model.supplierPayment.toDateClaimed.onSet = function(value) {    debugger;    this.toDateClaimed_int = value * multiplier;    this.thisClaimedAmount_int = this.toDateClaimed_int - this.prevToDateClaimed_int;};model.supplierPayment.toDateApproved.onSet = function(value) {    var newValue = value * multiplier;    this.toDateApproved_int = newValue;    this.thisApprovedAmount_int = this.toDateApproved_int - this.prevToDateApproved_int;    var theSubcontract = thePayment.paymentSubcontract;        if(theSubcontract.security_isCashRetention){    	    	calculateRetention(this);    }        calculateNet(this);};model.supplierPayment.methods.importJSON = function(jsonString) {    ds.supplierPayment.all().remove();    var objCollection = JSON.parse(jsonString);    objCollection.forEach(function(theObject) {        createSupplierPayment(theObject);    });}model.supplierPayment.thisClaimedAmount_int = new Attribute("storage", 'number');model.supplierPayment.thisApprovedAmount_int = new Attribute("storage", 'number');model.supplierPayment.thisApprovedAmountTax_int = new Attribute("storage", 'number');model.supplierPayment.thisRetentionTaken_int = new Attribute("storage", 'number');model.supplierPayment.thisRetentionReleased_int = new Attribute("storage", 'number');model.supplierPayment.prevToDateClaimed_int = new Attribute("storage", 'number');model.supplierPayment.prevToDateApproved_int = new Attribute("storage", 'number');model.supplierPayment.toDateClaimed_int = new Attribute("storage", 'number');model.supplierPayment.toDateApproved_int = new Attribute("storage", 'number');model.supplierPayment.events.init = function(event) {}//////////////////////////////////////////////////////////////////////////// Save//////////////////////////////////////////////////////////////////////////model.supplierPayment.events.save = function(event) {	debugger;    if (this.isNew() && !this.isBeingImported) {        initialisePayment(this);    }        if (this.isBeingImported) {    	    	this.isBeingImported = false;}}model.supplierPayment.entityMethods.remove = function() {    this.remove();}//////////////////////////////////////////////////////////////////////// //// Functions//////////////////////////////////////////////////////////////////////////function initialisePayment(thePayment) {    thePayment.paymentDate = new Date();    var theSubcontract = thePayment.paymentSubcontract;    var paymentsCollection = theSubcontract.payments;    var sortedPayments = paymentsCollection.orderBy('paymentNumber desc');    var lastNumber = theSubcontract.payments.max('paymentNumber');    var lastPayment = sortedPayments.first();    thePayment.isNewPayment = true;    thePayment.isInitialised = true; // added 2015-03-15 tells us this initialisation proceedure has been run    lastNumber++;    thePayment.paymentNumber = lastNumber;    thePayment.validationErrors = '{}';    thePayment.prevToDateClaimed_int = lastPayment.toDateClaimed_int;    thePayment.prevToDateApproved_int = lastPayment.toDateApproved_int;    thePayment.toDateClaimed_int = thePayment.prevToDateClaimed_int;    thePayment.toDateApproved_int = thePayment.prevToDateApproved_int;    thePayment.thisApprovedAmount_int = 0;    thePayment.thisClaimedAmount_int = 0;    thePayment.thisRetentionTaken_int = 0;    thePayment.thisRetentionReleased_int = 0;    thePayment.prevRetentionBalance_int = paymentsCollection.sum('prevRetentionBalance');}function calculateNet(thePayment) {    thePayment.thisPaidNet_int = thePayment.thisApprovedAmount_int - thePayment.thisRetentionTaken_int + thePayment.thisRetentionReleased_int;}function createSupplierPayment(theObject) {    var theSubcontract = ds.subcontract.find('id == :1', theObject.uid_scnt);    //var theProject = ds.project.find('uid_project = :1', theObject.uid_project);    //var theUser = ds.user.find('uid_user = :1', theObject.uid_user);    var thePeriod = ds.period.find('periodNumber == :1', theObject.accountingPeriod);    var thePayment = new ds.supplierPayment({        id: theObject.uid_spy,        paymentDate: theObject.paymentDate,        paymentNumber: theObject.paymentNumber,        paymentDetails: theObject.paymentDetails,        supplierReference: theObject.supplierReference,        isApproved: theObject.isApproved,        isExported: theObject.isExported,        isFinalPayment: theObject.isFinalPayment,        thisClaimedAmount_int: theObject.thisClaimedAmount * multiplier,        thisApprovedAmount_int: theObject.thisApprovedAmount * multiplier,        thisApprovedAmountTax_int: theObject.thisApprovedAmountGST * multiplier,        thisRetentionTaken_int: theObject.thisRetentionTaken * multiplier,        thisRetentionReleased_int: theObject.thisRetentionReleased * multiplier,        prevToDateClaimed_int: theObject.prevToDateClaimed * multiplier,        prevToDateApproved_int: theObject.prevToDateApproved * multiplier,        prevRetentionBalance_int: theObject.prevRetentionBalance * multiplier,        toDateClaimed_int: theObject.toDateClaimed * multiplier,        toDateApproved_int: theObject.toDateApproved * multiplier,        accountingPeriod: thePeriod,        paymentSubcontract: theSubcontract,        isBeingImported: true    });    thePayment.save();}function addError(thePayment, errorNumber, errorMessage) {    var theValidationErrors = JSON.parse(thePayment.validationErrors);    if (!theValidationErrors[errorNumber]) {        theValidationErrors[errorNumber] = errorMessage;        thePayment.validationErrors = JSON.stringify(theValidationErrors);    }}function removeError(thePayment, errorNumber) {    if (thePayment.validationErrors) {        var theValidationErrors = JSON.parse(thePayment.validationErrors);        delete theValidationErrors[errorNumber]; // no need to check if it is already there        thePayment.validationErrors = JSON.stringify(theValidationErrors);    }}function calculateRetention(thePayment){		var theSubcontract = thePayment.paymentSubcontract;	var theRetentionScheme = theSubcontract.retentionScheme;	var maximumRate_int = theRetentionScheme.maximumRate_int;	var retentionRate_int = theRetentionScheme.retentionRate_int;		var maxRetention_int = theSubcontract.amt_contractRevised_int*maximumRate_int;	var calcRetention_int = thePayment.toDateApproved_int * retentionRate_int;		}var multiplier = 1000000